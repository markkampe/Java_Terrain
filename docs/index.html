<html>
<head>
<title>WorldBuilder</title>
</head>
<body>
<center>
<H1>WorldBuilder - Code Overview</h1>
</center>
<H2>Introduction</h2>
<P>
This is an introduction to and overview of the code for the <em>WorldBuilder</em> application.
The intended audience is (ideally Java) programmers who are interested in understanding
the design and operation of this tool.
</P>
<P>
The descriptions are presented in three parts:
<ul>
    <li> Prose descriptions of the overall <a href="#overview">structure</a>, 
         and slightly more <a href="#drilldowns">detailed drill-downs</a>
	 on flow control, and most interesting operations.</li>
    <li> UML class diagrams for the
    	 <a href="#UML_fundamental">fundamental</a>,
	 <a href="#UML_display">info display dialog</a>,
    	 <a href="#UML_edit">map editing dialog</a>, and
	 <a href="#UML_export">output/export</a> classes.
    </li>
    <li> A fairly <a href="JavaDoc/index.html">complete set of JavaDocs</a>
    	 for all public methods and fields.</li>
</ul>
<H3>History</H3>
<P>
<P>
The development of this tool was motivated by 
<A href="https://www.linkedin.com/in/christopher-kampe-8a386048">Christopher Kampe</a>'s
observation that, in RPG development, the creation of the underlying maps had 
a relatively poor cost/value performance.  He wanted to make it easy for 
game developers to start with realistic maps, atop of which they could
add their more creative and interesting features and encounters.
</p>
This program is majorly inspired by the 
<A Href="https://mewo2.com">Marton O'Leary</a>'s
<A Href="https://twitter.com/unchartedatlas">Uncharted Atlas</A> project.
His
<A href="https://github.com/mewo2/terrain">Terrain Builder</a> is a
JavaScript Web-app to synthesize pages of a fantasy Atlas.
The <em>WorldBuilder</em> is Java application to enable game designers
to create 3D regional landscapes that can be exported as maps for a 
variety of computer-based Role Playing Games (starting with RPG Maker).
While these goals have very different scopes, calling for rather
different approaches, this program still draws heavily on several of
O'Leary's insights:
<UL>
   <LI> defining a large Cartesian landscape by
   	interpolations of the altitudes of (randomly
	placed) points in a Voronoi mesh.</li>
   <LI> defining (satisfyingly irregular) topographic
   	features by imposing vertical displacements associated
	with regular (e.g. conical) geometric figures
	on the random Voronoi mesh.</li>
   <LI> simplifying the simulation of water-flow by
   	restricing all flow to the paths between 
	(the few) points in the Voronoi mesh</li>
   <LI> using that flow to compute erosion as a 
   	downards deformation of the points through
	which water flowed.</li>
   <LI> defining geo-political borders as the points
   	where the cost of travel from two adjacent
	capitals are equal.</LI>
</UL>
</P>
<P>
The evolution of this tool has been driven by a combination of 
<A Href="https://www.linkedin.com/in/markkampe">Mark Kampe</a>'s 
architectural thoughts (about how to structure geo-physics simulations 
and plug-in RPG-map exporters) and
Christopher Kampe's experiences (with how to make a more usable tool
for creating satisfying worlds).
</P>

<a name="overview">
<H2>Structural Overview</H2>
</a>
<P>
To greatly over-simplify, this program can be divided into:
<ul>
	<li>a set of points (in a Voronoi, triangluar, mesh) each of which has
	    a variety of attributes (e.g. altitude, soil type, water flow).</li>
	<li>a collection of graphical renderers to display 2D maps to illustrate
	    those attributes (e.g. topography and water, erosion and deposition, etc.).</li>
	<li>a collection of exporters, to translate such maps into a form that can be
	    imported into another program (e.g. RPG Maker).</li>
	<li>a collection of dialogs and editors for changing the attributes (e.g.
	    creating mountains or changing water flow) of map points.</li>
	<li>a collection of menus and dialog widgets for accepting and executing commands.</li>
	<li>a collection of parsers to read program parameters, maps,
	    and export generation rules from (mostly <em>JSON</em>) configuration files.
</ul>
<P>
The classes that create and operate on Meshes of Voronoi points are
<A href="JavaDoc/worldBuilder/Mesh.html">Mesh.java</A>,
<A href="JavaDoc/worldBuilder/MeshPoint.html">Mesh.Pointjava</A> and
<A href="JavaDoc/worldBuilder/MeshPointHasher.html">MeshPointHasher.java</A>.
The set of MeshPoints that define the world are stored in a <em>Mesh</em> array.
Their attributes (e.g. altitude, soil type, water flow) are stored in parallel arrays
(e.g. <tt>Map.heightMap</tt>, <tt>Map.soilMap</tt>, <tt>Map.fluxMap</tt>) ... 
all of which are accessed through their common <em>MeshPoint index</em>.
</P>
<P>
There are several different map renderers, one for each major attribute:
<ul>
    <li> <a Href="JavaDoc/worldBuilder/AltitudeMap.html">AltitudeMap.java</a>,</li>
    <li> <a Href="JavaDoc/worldBuilder/TopoMap.html">TopoMap.java</a>,</li>
    <li> <a Href="JavaDoc/worldBuilder/WaterMap.html">WaterMap.java</a>,</li>
    <li> <a Href="JavaDoc/worldBuilder/RiverMap.html">RiverMap.java</a>,</li>
    <li> <a Href="JavaDoc/worldBuilder/RainMap.html">RainMap.java</a>,</li>
    <li> <a Href="JavaDoc/worldBuilder/ErodeMap.html">ErodeMap.java</a>,</li>
    <li> <a Href="JavaDoc/worldBuilder/SoilMap.html">SoilMap.java</a>.</li>
</ul>
The mapping from a (sparse and irregular) Voronoi mesh to a 
(dense and continuous) 2D map is greatly facilitated by the
<a Href="JavaDoc/worldBuilder/Cartesian.html">Cartesian.java</a>
interpolation service.
The overall orchestration of creating a display from all of these
independent layers is managed by (the largest and most important class in the program)
<a Href="JavaDoc/worldBuilder/Map.html">Map.java</a>.
</P>
<P>
All Exporters implement a 
<a Href="JavaDoc/worldBuilder/Exporter.html">standard interface</a>,
and a common
<a Href="JavaDoc/worldBuilder/ExportBase.html">export orchestrater</a>
creates a series of 2D per-tile maps which it pushes to the
output-format-specific implementations.
The simplest of these,
<a Href="JavaDoc/worldBuilder/RawExport.html">RawExport.java</a>
and 
<a Href="JavaDoc/worldBuilder/JsonExporter.html">JsonExporter.java</a>,
simply create a collection of per-point attribute descriptions.
More interesting is
<a Href="JavaDoc/worldBuilder/RPGMexport.html">RPGMexport.java</a>,
which uses tile placement rules (managed by
<a Href="JavaDoc/worldBuilder/TileRule.html">TileRule.java</a> and
<a Href="JavaDoc/worldBuilder/TileRules.html">TileRules.java</a>)
to drive a very <em>RPG-Maker</em>-savvy
<a Href="JavaDoc/worldBuilder/RPGMTiler.html">RPGMTiler.java</a>
to reproduce the map in tiles, and cause the (<em>RPG Maker map</em>) output to be written by
<a Href="JavaDoc/worldBuilder/RPGMwriter.html">RPGMwriter.java</a>.
</P>
<P>
The main-screen menus and controls are put-up and responded to by the main class
(<a Href="JavaDoc/worldBuilder/WorldBuilder.html">WorldBuilder.java)</a>.
<br>
Simple operations like saving updated maps and loading new ones, it handles
directly.  But display and update operations are handled by one
of the sub-dialog managers:
<ul>
   <li> <a Href="JavaDoc/worldBuilder/MeshDialog.html">MeshDialog.java</a>,</li>
   <li> <a Href="JavaDoc/worldBuilder/WorldDialog.html">WorldDialog.java</a>,</li>
   <li> <a Href="JavaDoc/worldBuilder/MountainDialog.html">MountainDialog.java</a>,</li>
   <li> <a Href="JavaDoc/worldBuilder/LandDialog.html">LandDialog.java</a>,</li>
   <li> <a Href="JavaDoc/worldBuilder/RainDialog.html">RainDialog.java</a>,</li>
   <li> <a Href="JavaDoc/worldBuilder/RegionDialog.html">RegionDialog.java</a>,</li>
   <li> <a Href="JavaDoc/worldBuilder/RiverDialog.html">RiverDialog.java</a>,</li>
   <li> <a Href="JavaDoc/worldBuilder/PointDebug.html">PointDebug.java</a>,</li>
   <li> <a Href="JavaDoc/worldBuilder/SlopeDialog.html">SlopeDialog.java</a>,</li>
   <li> <a Href="JavaDoc/worldBuilder/ZoomDialog.html">ZoomDialog.java</a>,</li>
   <li> <a Href="JavaDoc/worldBuilder/RuleDebug.html">RuleDebug.java</a>.</li>
</ul>
These put-up and respond to their own widgets, but on-map selection
(e.g. of lines, rectangles or groups of MeshPoints) is handled by
<a Href="JavaDoc/worldBuilder/Map.html">Map.java</a>.
<br>
These dialogs effect their updates by creating updated copies of
the attribute maps (arrays containing the values of a particular attribute
for each <em>MeshPoint</em>) and calling <em>set</em> functions
(e.g. <tt>setHeightMap()</tt> or <tt>setSoilMap()</tt>) in the
in the <em>Map</em> class.
</P>
<P>
The most complex module is probably the 
<a Href="JavaDoc/worldBuilder/Hydrology.html">Hydrology</a> class,
which uses rainfall and topology to compute water flow, erosion, 
deposition, and lake boundaries.
</P>
<P>
Most program parameters are read-in and accessed through the <em>Singleton</em>
implemented by
<a Href="JavaDoc/worldBuilder/Parameters.html">Parameters.java</a>.
<br>
When a map is read in (or written out), this is done by
<a Href="JavaDoc/worldBuilder/Map.html">Map.java</a>.
<br> 
<em>RPG Maker</em> tile placement rules are read in by 
<a Href="JavaDoc/worldBuilder/TileRules.html">TileRules.java</a>.
</P>
<P>
Most operations are initiated as a result of widget actions in the main class,
and most of those result in the creation of a new interactive dialog
by one of the sub-dialog managers.
</P>

<a name="drilldowns">
<H2>Key Classes and Operations</H2>
</a>
<P>
The <em>worldBuilder</em> application is moderately large
(over 10,000 lines of code spread over a few dozen modules).
The high level class structure can be (crudely) summarized by
a few UML class diagrams.
</P>
<H3>Mesh and Map-related Classes</h3>
<P>
The first class diagram shows the main <em>WorldBuilder</em> class,
the <em>awt</em> and <em>swing</em> GUI classes it builds on,
and the <em>Map</em> and <em>Mesh</em> classes that support
the <em>MeshPoints</em> on which the map is based.
Note that the only <em>Map</em> methods shown in this 
figure are those involved in basic map creation.
</P>
<a name="UML_fundamental"></a>
<img src="Fundamental.png" width="600">
<H4>Mesh Creation</H4>
<P>
O'Leary observed that if we create map points in a rectilinear grid,
deformations tend to retain that (unnatural) rectilinearity.  This
problem is elimnated if the map points are placed at random.  
Truly random points exhibit unattractive degrees of sparse-ness
and clumpy-ness.  O'Leary evens this out by a few iterations
of connecting points into a Voronoi mesh and then choosing,
as new points, the centroids of those Voronoi polygons.
We use a <em>Voronoi</em> library to assign three neighbors to
each point and create the desired Mesh.
</P>
<H3>Simple Dialog Classes</h3>
<P>
The second class diagram shows the simpler (non-point-attribute-editing)
dialogs and the primary <em>Map</em> class functions they use.
</P>
<a name="UML_display"></a>
<img src="ViewDialogs.png" width="800">
<P>
These are all very simple dialogs.  Some of them
(e.g. <em>PointDebug</em>) simply display the attributes of
a selected point.  
Others simply update parameters (e.g. <em>WorldDialog</em> 
adjusts the latitude, longitude and size of the world map).  
The most complex is probably the <em>ZoomDialog</em>, which
allows a sub-region of the world map to be selected, and
uses the <em>Map.setWindow</em> function to cause the 
displayed map to zoom into the selected sub-region.
</P>
<H4>Point and Region Selection</H4>
<P>
The <em>Map</em> class is a <em>Mouse</em> and <em>MouseMotion</em>
<em>Listener</em>, interprets mouse actions as selection attempts,
and indicates the selected points/areas on the currently displayed
map.  Any dialog that needs to know about point or region selections
can register as a 
<a Href="JavaDoc/worldBuilder/MapListener.html">MapListener</a>
and receive call-backs in response to selection actions.  They can
also use the <tt>Map.selectMode()</tt> and <tt>Map.checkSelection()</tt>
operations to enable the desired selection mode (e.g. point, line, region)
and query any selections that may have already been made.
</P>
<H3>Terrain Editing Dialog Classes</H3>
<P>
The third class diagram shows the attribute-editing dialogs and the
<em>Map</em> selection and get/set functions they use to update
the <em>MeshPoint</em> attribute maps.
</P>
<a name="UML_edit"></a>
<img src="EditDialogs.png" width="2000">
</P>
<P>
The operations in this richer set of dialogs (a) update point attributes and 
(b) drive refreshes of the displayed map to show the updated information.
</P>
<H4>Attribute Maps</H4>
<P>
As random points in a 2D space <em>MeshPoint</em>s are not very exciting.
What makes them interesting is the collection of attributes associated
with each point.  As mentioned previously, each <em>MeshPoint</em> has
a stable index in the <em>Mesh</em> array, and the <em>MeshPoint</em>
attributes are stored in series of parallel arrays:
<ul>
	<li><tt>heightMap</tt> stores the altitude (in -0.5 to +0.5 map coordinates) 
	     of each <em>MeshPoint</em></li>
	<li><tt>soilMap</tt> stores the mineral type (sedimentary, metamorphic, igneous, alluvial)
	     of each <em>MeshPoint</em></li>
	<li><tt>rainMap</tt> stores the annual rainfal (in cm)
	     for each <em>MeshPoint</em></li>
	<li><tt>hydrationMap</tt> stores the depth (in meters) of water
	     on top of  each <em>MeshPoint</em></li>
	<li><tt>fluxMap</tt> stores the flow of water (in cubic meters/year) 
	     into each <em>MeshPoint</em></li>
	<li><tt>erodeMap</tt> stores the net (negative) erosion or (positive) sedimentation
	     of each <em>MeshPoint</em></li>
</ul>
The attribute editing dialogs load the appropriate attribute maps from the <em>Map</em>
class, update them according to the user's instructions, and then pass the
updated values back to the <em>Map</em> class.
</P>

<H4>Displayed Map(s)</H4>
<P>
Whenenver attributes are changed the <em>awt.repaint()</em> method invoked,
causing a call to <tt>Map.paintComponent()</tt>.
</P>
<P>
There are many different
attributes for each <em>MeshPoint</em>.  Which will be displayed is controlled
by calls to <tt>Map.setDisplay()</tt>.
</P>
<P>
When the call is made to repaint the map, <tt>Map.PaintComponent</tt> will:
<ol type="1">
	<li>decide on the dimensions of the (to be updated) map.</li>
	<li>create a <em>Cartesian</em> interpolation matrix to compute
	    the values at every pixel from the nearest three <em>MeshPoints</em>.</li>
	<li>go through the display-enabled attributes, using the 
	    appropriate map-rendering class
	    (e.g. <tt>AltitudeMap</tt> or <tt>RiverMap</tt>) to compute
	    the attribute values for every pixel on the map and generate
	    the appropriate display updates.</li>
	<li>if any selection areas are to be highlighted, add appropriate
	    rectangles, lines or point-halos to indicate them.</li>
</ol>
</P>
<H3>Export Classes</H3>
<P>
The final class diagram shows the <em>Export</em> related classes
(that handle both raw JSON and <em>RPG Maker</em> maps).
</P>
<a name="UML_export"></a>
<img src="ExportDialogs.png" width="1200">
<P>
</P>
<H3>Notes on hydrological simulations</H3>
<P>
The most important methods in the
<a Href="JavaDoc/worldBuilder/Hydrology.html">Hydrology</a> class are:
<ul>
    <li> <em>drainage</em> ... figure out how water would flow between the mesh points:
        <ol type="1">
	    <li> mark all sub-sea-level points on the edge of the map as oceanic.</li>
	    <li> determine the most down-hill (steepest) neighbor or each land point.</li>
	    <li> identify the lowest point in each depression (sink).</li>
	    <li> identify the lowest escape point for each depression (sink) if it fills with water ...
	         and if the escape is into a larger depression, combine them.</li>
	    <li> create a <em>source-to-sink ordered</em> list of non-oceanic points
	         (to be used in the next pass).</li>
	</ol>
    </li>
    <P>
    </P>
    <li> <em>waterFlow</em> ... compute water velocity, erosion, deposition, and lake boundaries:
        <ol type="1">
	    <li> compute the incoming rainfall and flow, vs evaporation to determine
	         whether or not there is net water (flowing or lake) on each point.</li>
	    <li> use the down-hill slope to compute the velocity of flow through each point.</li>
	    <li> if the velocity is high enough to cause erosion, compute the amount of
	         soil removed from this point and added to the flow.</li>
	    <li> if the velocity is lowe enough to cause sedimentation, compute how
	         much soil is removed from the flow and deposited on this point.</li>
	    <li> if this point is in a depression, compute the water depth 
	    	 (as the altitude difference between this point and its escape point identified
		 in the <em>drainage</em> pass).</li>
	</ol>
    </li>
    <P>
    </P>
    <li> <em>erosion</em> ... return the (number of meters of) erosion for 
    	 a specified mesh point (based on the <em>waterFlow</em> computations).</li>
    <P>
    </P>
    <li> <em>sedimentation</em> ... return the (number of meters of) sedimentation for
    	 a specified mesh point (based on the <em>waterFlow</em> computations).</li>
</ul>
</P>
<P>
I started out trying to use real physics for erosion and sedimentation:
<ul>
   <li> the Manning formula to compute water velocity from slope.</li>
   <li> suspended concentration studies to estimate how much soil could be carried by water at each speed.
   <li> the Hjulstrom curves to distinguish erosion and deposition ranges.</li>
</ul>
</P>
but the results were disappointing:
<ul>
   <li> Fantasy maps seem to have a wider vertical range than real topographies,
   	so the water would always be moving too fast for any sedimentation to happen.
	<P>
	I dealt with this by changing the velocity computation to simply interpolate a 
	reasonable range of water speeds (0.005m/s - 3m/s) from a wide range of 
	slopes (1/1000 - 1/1).
   </li>
   <li> The Hjulstrom curves tell us what sized particles are being eroded
        or deposited at a given velocity, but not the rate at which these
	processes proceed.
	<P>
	Based on my experience with other such processes, I asserted 
	that erosion and deposition were exponential processes,
	with some fraction of the possible erosion/deposition happening
	at each mesh point.  The possible erosion was proportional to 
	the water velocity, and the deposition inversely proportional to 
	the water velocity.  The fraction of possible erosion/deposition
	that happens per MeshPoint is controlled by two tunable parameters:
	<em>Ce</em> and <em>Cd</em>.
   </li>
   <li> Silt is not dug out of the river-bed, but washed off the top 
        of the entire watershed.  Consequently, the amount of silt
	deposition should greatly exceed the amount of river-bed
	erosion.
   	<P>
	I dealt with this by making silt deposition a distinct process
	from the deposition of eroded rock, and making the simplifying
	assumption that sufficently slow moving water always has more 
	silt to deposit.
   </li>
</ul>
<P>
I have seen much higher resolution erosion/deposition simulations,
performed by GPUs on a much denser Cartesian grid.  The results were
very beautiful, but require many orders of magnitude more computer
power (to do anything), and lack the (very satisfying) irregularity
that emerges from points on our (very sparse) Voronoi mesh.
The erosion/deposition models used by those simulations were much
simpler than mine:
<UL>
    <li> velocity is a simple function of slope, and the allowable
    	 amount of sediment carried by water is directly proportional
	 to its velocity.</li>
    <li> erosion is the shortfall (amount of allowable sediment not
         yet carried) divided by the hardness of the rock.</li>
    <li> deposition is the surplus (amount of carried sediment
         beyond what is currently allowed for that water).</li>
</UL>
</P>
<P>
I was impressed by the simplicity of these models, and incorporated
some of those lessons into the above solutions.  But (O'Leary's insight)
performing all topographic operations on a (manageably small number of 
points) Voronoi grid is fundamental to how this program works, and
moving to an entirely (much finer grained) Cartesian model is a
different program.
</P>

<H2>Issues</H2>
<H3>MeshPoint to Cartesian Conversion</H3>
<P>
A <a Href="JavaDoc/worldBuilder/Cartesian.html">Cartesian</a> map
specifies, for each square in a Cartesian grid, a list of surrounding
<a Href="JavaDoc/worldBuilder/MeshPoint.html">MeshPoint</a>s and
their distances from this square.  From this list, we can interpolate
from a list of per-MeshPoint values to per-Cartesian-square values.
The interpolation process is trivial (simply the inverse-distance-weighted
average of the values for the surrounding MeshPoints).
The hard part is figuring out which MeshPoints are the surrounding ones.
</P>
<P>
The best answer would seem to be those MeshPoints that define the
Voronoi polygon within which the Cartesian point lies.  The
<em>Cartesian</em> constructor and <em>nextPoint</em> methods
attempt to enumerate these points by:
<ul>
   <li> starting with the MeshPoint nearest to the desired Cartesian square</li>
   <li> choosing, at each successive point, the path that seems most likely 
   to be enclosing the desired polygon.
	<P>
	A human would use a simple heuristic (like always turn
	to the right).  I compute, for each possible (non-reversing) path, 
	the derivative of radius (distance from the Cartesian center) with 
	respect to circumference (distance from the previous
	vertex).  Minimizing this ratio tends to keep us on
	the most concave path.
	</li>
</ul>
This works reasonably for points that are within the Voronoi mesh.
But for points outside the edges of the mesh, there is no surrounding
polygon, so the above works badly.  This results in attempting to 
interpolate values from (poorly chosen) non-neighbors, giving rise
to strange altutudes and water bodies near the edges of the map.
</P>
<P>
If we knew that a point was outside of the mesh, we could probably
interpolate reasonable values by considering only the one or two nearest
MeshPoints.  But how can we know whether or not a point is outside
the mesh (or inside a computed polygon)?  The problem of
<em>point in polygon</em> determination turns out to be a fairly
expensive one ... and we need to solve it for a very large number
of points (every time we zoom, sub-region, export, or define a new mesh).
The <em>Vicnity.outsideMesh</em> function uses a few cheap
heuristics to recognize more obvious cases ... but there
are points near non-convex outer borders that are not
recognized, and therefore still interpolate badly.
</P>
The problem is relatively minor, in that it only happens to non-ocean
points at the outer-most edges of the map ... and is only then noticable
if there is wide range of altitude and land/water variation among the dozen
nearest MeshPoints.  Most people will never encounter it, and those who do are
unlikely to notice it.  But, in the interests of correctness ...
<ul>
   <li> If we simply limit the displayed (and exportable) map to
        be entirely within the Voronoi mesh, this problem ceases
	to happen.</li>
   <li> The only thing I wanted from the Voronoi package was the
   	MeshPoint connections (which drive water flow)
	... but the Voronoi analysis had actually identified all 
	of the polygons.  If we kept the polygon definitions
	and exploited more of the Voronoi package services
	we might be able to greatly improve the efficiency of
	finding the surrounding MeshPoints for Cartesian translation,
	and perhaps solve this problem as well.</li>
</ul>

<H2>Musings</H2>
<P>
TO BE CONTINUED
</P>

</body>
</html>
